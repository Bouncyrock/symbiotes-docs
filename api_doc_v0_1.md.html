<title>Symbiote API 0.1</title>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico"><meta charset="utf-8" emacsmode="-*- markdown -*-"><link rel="stylesheet" href="ts_api_docs.css">
# com.bouncyrock.talespire.v0_1

# boards

## `whereAmI`

**Parameters**

none

**Returns**

[boardFragment](#types/boardfragment)

**Description**

Returns the board fragment of the currently loaded board.

<br><br>
## `getBoardsInThisCampaign`

**Parameters**

none

**Returns**

Array[[boardFragment](#types/boardfragment)]

**Failure States**

- insufficientRights
**Description**

Returns a list of board fragments of all the boards in the currently active campaign.

<br><br>
## `getMoreInfo`

**Parameters**

        Name        |        Type         | Description
--------------------|---------------------
 boardFragmentOrIds | Array[fragmentOrId]

**Returns**

Array[[boardInfo](#types/boardinfo)]

**Description**

Returns more info on the specified board.

<br><br>
# bookmarks

## `getBookmarksInThisCampaign`

**Parameters**

none

**Returns**

Array[[bookmark](#types/bookmark)]

**Failure States**

- insufficientRights
**Description**

Returns a list of all bookmarks in the currently active campaign.

<br><br>
## `getBookmarksInThisBoard`

**Parameters**

none

**Returns**

Array[[bookmark](#types/bookmark)]

**Failure States**

- insufficientRights
**Description**

Returns a list of all bookmarks in the currently loaded board.

<br><br>
## `gotoBookmark`

**Parameters**

         Name         |     Type     | Description
----------------------|--------------
 bookmarkFragmentOrId | fragmentOrId

**Returns**

none

**Failure States**

- invalidBookmarkId
- couldNotFindBookmark
- couldNotFindBoard
**Description**

Sends the own clients' camera to the specified bookmark, identically to how it would work when searching for the bookmark in the boards list and clicking on it there or how a `talespire://goto/bookmark/` links behaves.

<br><br>
## `sendToBookmark`

**Parameters**

         Name         |        Type         | Description
----------------------|---------------------
 bookmarkFragmentOrId | fragmentOrId       
 clientFragmentsOrIds | Array[fragmentOrId]

**Returns**

none

**Failure States**

- invalidBookmarkId
- couldNotFindBookmark
- couldNotFindBoard
- insufficientRights
**Description**

Sends the specified list of clients (can also only be one) to the specified bookmark, identically to how it would work when searching for the bookmark in the boards list and clicking on it there or how a `talespire://goto/bookmark/` links behaves.

<br><br>
# campaigns

## `whereAmI`

**Parameters**

none

**Returns**

[campaignFragment](#types/campaignfragment)

**Description**

Returns info about the campaign that the current user client (ie: The one running this Symbiote) is in.

<br><br>
## `getMoreInfoAboutCurrentCampaign`

**Parameters**

none

**Returns**

[campaignInfo](#types/campaigninfo)

**Description**

Returns more info on the specified campaign.

<br><br>
# chat

## `send`

**Parameters**

  Name   |     Type     | Description
---------|--------------|-------------
 message | string       | truncated if length > 400
 target  | fragmentOrId | 

**Returns**

none

**Failure States**

- invalidTarget
- invalidPlayerId
**Description**

Sends the text specified in `message` to the given `target` via chat. Target can be either a single player fragment or player ID (not client ID) or one of the following keywords: "gms", "board", "campaign" which send to all GMs, all players on the current board or all players online respectively. All GMs specifically sends to all clients that have GM permissions, regardless of whether they currently are or aren't in GM mode. Received chat messages trigger the `chatMessageReceived` event from the [onChatEvent](#subscriptions/chat/onchatevent) event source.

Chat allows for rich text formatting within the feature set of Unity's [TextMeshPro](https://docs.unity3d.com/Packages/com.unity.textmeshpro@3.2/manual/RichText.html).

<br><br>
## `multiSend`

**Parameters**

            Name            |        Type         | Description
----------------------------|---------------------|-------------
 message                    | string              | truncated if length > 400
 targetPlayerFragmentsOrIds | Array[fragmentOrId] | 

**Returns**

none

**Description**

Sends chat messages to several players at once. Can either be provided with an array of player fragments or array of player IDs. Useful if you want to target several players with the same message, if you want to send the same message to all players you can instead use [chat.send](#chat/send) with the target "board" or "campaign". The target keywords used in [chat.send](#chat/send) don't work here. Received chat messages trigger the `chatMessageReceived` event from the [onChatEvent](#subscriptions/chat/onchatevent) event source.

Chat allows for rich text formatting within the feature set of Unity's [TextMeshPro](https://docs.unity3d.com/Packages/com.unity.textmeshpro@3.2/manual/RichText.html).

<br><br>
## `sendAsCreature`

**Parameters**

         Name         |     Type     | Description
----------------------|--------------|-------------
 message              | string       | truncated if length > 400
 creatureFragmentOrId | fragmentOrId | 
 target               | string       | 

**Returns**

none

**Failure States**

- invalidCreatureId
- invalidTarget
- insufficientRights
**Description**

Sends a chat message as the specified creature. Creatures can either be specified by their ID, or by their fragment object which is returned by any of the functions returning creatures, like getCreaturesInParty or getSelectedCreatures. Message and target work the same as with the [chat.send](#chat/send) function call.

Chat allows for rich text formatting within the feature set of Unity's [TextMeshPro](https://docs.unity3d.com/Packages/com.unity.textmeshpro@3.2/manual/RichText.html).

<br><br>
## `multiSendAsCreature`

**Parameters**

            Name            |        Type         | Description
----------------------------|---------------------|-------------
 message                    | string              | truncated if length > 400
 creatureFragmentOrId       | fragmentOrId        | 
 targetPlayerFragmentsOrIds | Array[fragmentOrId] | 

**Returns**

none

**Failure States**

- invalidCreatureId
- insufficientRights
**Description**

Sends chat messages to several players at once as the specified creature. See [chat.sendAsCreature](#chat/sendascreature) for how to specify the creature to speak as. Message and target work the same as with the [chat.multiSend](#chat/send) function call. Received chat messages trigger the `chatMessageReceived` event from the [onChatEvent](#subscriptions/chat/onchatevent) event source.

Chat allows for rich text formatting within the feature set of Unity's [TextMeshPro](https://docs.unity3d.com/Packages/com.unity.textmeshpro@3.2/manual/RichText.html).

<br><br>
# clients

## `whoAmI`

**Parameters**

none

**Returns**

[clientFragment](#types/clientfragment)

**Description**

Returns the client fragment of the own client (= The client that this Symbiote is running in).

<br><br>
## `getClientsInThisBoard`

**Parameters**

none

**Returns**

Array[[clientFragment](#types/clientfragment)]

**Description**

Returns a list of all clients currently connected to this board.

<br><br>
## `isMe`

**Parameters**

        Name        |     Type     | Description
--------------------|--------------
 clientFragmentOrId | fragmentOrId

**Returns**

boolean

**Description**

Returns true if the specified client ID (or client fragment) is the same client as the one running the Symbiote (= whether the client is your own client). Returns false otherwise.

<br><br>
## `getMoreInfo`

**Parameters**

         Name         |        Type         | Description
----------------------|---------------------
 clientFragmentsOrIds | Array[fragmentOrId]

**Returns**

Array[[clientInfo](#types/clientinfo)]

**Description**

Returns more info on the specified client.

<br><br>
# contentPacks

## `getContentPacks`

**Parameters**

none

**Returns**

Array[[contentPackFragment](#types/contentpackfragment)]

**Description**

Returns a list of all currently loaded content packs as fragments. Content packs can be loaded in and out at runtime (see [contentPacks.onContentPackChange](#contentpacks/oncontentpackchange)) as a preparation for asset modding support, currently the official asset packs are all loaded at the start.

<br><br>
## `getMoreInfo`

**Parameters**

           Name            |        Type         | Description
---------------------------|---------------------
 contentPackFragmentsOrIds | Array[fragmentOrId]

**Returns**

Array[[contentPackInfo](#types/contentpackinfo)]

**Description**

Returns the all content pack elements (all tiles, props, minis, music, ...) for the specified content pack(s). This contains all the content pack elements alongside their metadata like tags, sizes, icon positions in the atlas, etc.

<br><br>
## `findBoardObjectInPacks`

**Parameters**

          Name           |                       Type                       | Description
-------------------------|--------------------------------------------------
 boardObjectFragmentOrId | fragmentOrId                                    
 contentPacksInfos       | Array[[contentPackInfo](#types/contentpackinfo)]

**Returns**

[boardObjectFindResult](#types/boardobjectfindresult)

**Description**

Takes a board object fragment or ID, as well as a list of contentPacksInfos to find the specified board object in the packs. A board object is a tile, prop or mini and the ID or fragment can for example be found by parsing a slab received from [slabs.getSlabInActiveSelection](slabs/getslabinactiveselection).
contentPacksInfos can be queried by calling [contentPacks.getMoreInfo](#contentpacks/getmoreinfo).
This function will only search through content packs that are provided, which means that you can search through only a subset of content packs by passing it an array of content packs that don't include all content packs. If the specified board object is not found in any of the provided packs, it will return a notFound error.

<br><br>
## `createThumbnailElementForBoardObject`

**Parameters**

      Name       |  Type  | Description
-----------------|--------
 boardObjectInfo | object
 size            | int   

**Returns**

object

**Description**

Creates a DOM element showing the library thumbnail for the specified board object (= tile, prop or mini). Optionally allows a size to be set, defaults to 128x128px. The board object info can be found in the content packs returned by [contentPacks.getMoreInfo](#contentpacks/getmoreinfo), though a helper function for searching through content packs is also provided: [contentPacks.findBoardObjectInPacks](#contentpacks/findboardobjectinpacks).
The return element is a DOM element that can be added into the DOM with various JS functions, for example: [appendChild](https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild) or [prepend](https://developer.mozilla.org/en-US/docs/Web/API/Element/prepend).

<br><br>
# creatures

## `getUniqueCreaturesInThisCampaign`

**Parameters**

none

**Returns**

Array[[creatureFragment](#types/creaturefragment)]

**Failure States**

- insufficientRights
**Description**

Returns a list of all unique creatures (as fragments) in the currently active campaign.

<br><br>
## `getCreaturesOwnedByPlayer`

**Parameters**

        Name        |     Type     | Description
--------------------|--------------
 playerFragmentOrId | fragmentOrId

**Returns**

Array[[creatureFragment](#types/creaturefragment)]

**Failure States**

- invalidPlayerId
- insufficientRights
**Description**

Returns a list of all unique creatures (as fragments) owned by a specific player. Player can be specified either as id or as a player fragment.

<br><br>
## `getSelectedCreatures`

**Parameters**

none

**Returns**

Array[[creatureFragment](#types/creaturefragment)]

**Description**

Returns a list of all currently selected creatures. This can either be an array of length 1 if just one creature is selected (or 0 if none), or an arbitrary length of up to 50 when groups of minis are selected with the lasso.

<br><br>
## `getMoreInfo`

**Parameters**

          Name          |        Type         | Description
------------------------|---------------------
 creatureFragmentsOrIds | Array[fragmentOrId]

**Returns**

Array[[creatureInfo](#types/creatureinfo)]

**Description**

Returns more info on the specified mini. This includes states like knockdown, their stats, names, morphs, etc. GMs (including players who can GM, but are in player mode currently) can see all the info on all the minis, players will only see data they themselves can find out through the TaleSpire UI, meaning most data is only visible on minis they own.

<br><br>
## `getCreatureStatNamesForThisCampaign`

**Parameters**

none

**Returns**

Array[string]

**Description**

Returns an array of length 8 with the stat names as set in the campaign settings.

<br><br>
## `createBlueprint`

**Parameters**

     Name     |                Type                 | Description
--------------|-------------------------------------
 creatureInfo | [creatureInfo](#types/creatureinfo)

**Returns**

string

**Description**

Returns a `talespire://` URL creature blueprint created from the specified creature info. This can either be the creature info for an existing creature on the board or an edited (or completely newly created) creature info object. The ID of creature info is not used, so does not need to be populated when creating a creature info object from scratch.

<br><br>
# debug

## `log`

**Parameters**

 Name |  Type  | Description
------|--------
 msg  | object

**Returns**

none

**Description**

Writes the given string into a Symbiote-specific `log.txt` file located in a `.debug` folder in the directory of the Symbiote itself. Each call to debug.log writes in a new line into the log. For delevopment purposes the browser's console.log is likely to be more useful, but debug.log allows a simple way for users to send log files to the Symbiote developers without needing to know how to attach the Chrome dev tools to the Symbiote and how to read/export the console messages.

Symbiote logs are kept like the Game logs are: Starting the Symbiote checks whether a `log.txt` already exists and if so moves it to `log-prev.txt`. The first call to `debug.log` then creates a new `log.txt` file and for the rest of the Symbiote's execution it will keep writing to the newly created file.

<br><br>
# dice

## `isValidRollString`

**Parameters**

  Name   |  Type  | Description
---------|--------
 rollStr | string

**Returns**

boolean

**Description**

Returns true if the given string is a valid dice roll string, false if not. A roll string can consist of several roll groups separated by forward slashes `/` and then a dice roll with each an arbitrary amount of dice or static modifiers chained with operators. For a more in-depth description of the dice string format, see "Dice Links" section [here](https://feedback.talespire.com/kb/article/talespire-url-scheme).
Examples: `3d12`, `2d20+3`, `d8+5d6+2d4+2/d20+7`

<br><br>
## `makeRollDescriptors`

**Parameters**

    Name    |  Type  | Description
------------|--------
 rollString | string

**Returns**

Array[[rollDescriptor](#types/rolldescriptor)]

**Description**

Takes a dice roll string and returns an array of intermediate descriptor objects for use in [dice.putDiceInTray](#dice/putdiceintray). Each array entry corresponds to one dice group (separated by a forward slash `/`) See [dice.isValidRollString](#dice/isvalidrollstring) for more info on what a roll string is.

<br><br>
## `evaluateDiceResultsGroup`

**Parameters**

     Name     |                    Type                     | Description
--------------|---------------------------------------------
 resultsGroup | [rollResultsGroup](#types/rollresultsgroup)

**Returns**

int

**Failure States**

- invalidOperand
- invalidOperator
**Description**

Evaluates a results group from the dice results according to their operators. Uses the same logic as TaleSpire itself to evaluate the results group, meaning it will always stay consistent with the native dice results, but still allows you handling the results of individual groups differently to for example implement a "keep highest group" function.

<br><br>
## `sendDiceResult`

**Parameters**

      Name      |                        Type                        | Description
----------------|----------------------------------------------------
 resultGroups   | Array[[rollResultsGroup](#types/rollresultsgroup)]
 optionalRollId | string                                            

**Returns**

string

**Failure States**

- emptyGroupResults
- invalidDiceType
- invalidOperator
- invalidScore
- invalidModifier
- invalidOperand
- invalidRollId
**Description**

Sends a dice result for the TaleSpire UI to display. resultGroups is structured identically to a native dice roll result like could be returned from the [dice.rollResults](#dice/rollresults) event source. Can optionally specify a rollId that can correspond to a dice roll within TaleSpire, like one that was created by [dice.putDiceInTray](#dice/putdiceintray). If not specified it is treated as a "new" dice roll and has no association to any dice on the board. All dice results that were sent using this function have an indicator in the UI that show this dice result was sent by a Symbiote which allows GMs to differentiate between known good rolls done from within TaleSpire and results that a player could have tampered with (like for example by always sending a dice result that has a specific value instead of a random result).

<br><br>
## `putDiceInTray`

**Parameters**

      Name       |                      Type                      | Description
-----------------|------------------------------------------------
 rollDescriptors | Array[[rollDescriptor](#types/rolldescriptor)]
 quietResults    | boolean                                       

**Returns**

string

**Failure States**

- foundEmptyDiceGroup
- unsupportedSidesCount
- unsupportedDieCount
- noDiceSpecified
- notInBoard
**Description**

Puts a dice roll specified by an array of roll descriptors into the tray ready for the player to roll. If hideResults is set to true, the result of the roll will not be shown and will also not be visible to players in the chat history. GMs will have an indicator of when a roll with hidden results has happened that they can click to see the results of this roll. This is meant to work in conjunction with [dice.sendDiceResult](#dice/senddiceresult) so Symbiotes can "override" the roll result, while retaining the GMs ability to cross check what was rolled and what was reported to be the result, because Symbiotes can report any result they like and as such could be used to cheat rolls.

Returns a rollId used to keep track of this specific roll in the future. Any subsequent roll of these dice will use this rollId, as well as the "rollCleared" event of [dice.rollResults](#dice/rollresults).

Once the dice have been rolled their result can be read from the `rollResults` event from the [onRollResults](#subscriptions/dice/onrollresults) event source.

<br><br>
# initiative

## `getQueue`

**Parameters**

none

**Returns**

[initiativeQueue](#types/initiativequeue)

**Description**

Returns the contents of the turn queue as a list. Each entry in the list contains an id, a name and a kind - as of right now the kind will always be "creature", but later on the turn queue is intended to be able to store more than just creatures (eg: AoE markers), so checking for which kind it is should be done already to not encounter bugs whenever the initiative mode gets updated.

The turn queue is still accessible with this call even if the client is currently not in initiative mode, as of right now there are no API calls for determining which game mode (exploration/initiative/cutscene) the client is in.

<br><br>
# localStorage

## global

### `setBlob`

**Parameters**

 Name |  Type  | Description
------|--------
 str  | string

**Returns**

none

**Failure States**

- ensurePathFailed
- writeFailed
- dataTooLarge
**Description**

Stores the given string of data in a file in the Symbiote's directory. The text given can be formatted as needed; plain text, JSON, XML, etc. Text size is limited to 5MB. All [localStorage.global](#localstorage/global) access the same file in storage, no matter which campaign is currently active. If campaign specific storage is needed (eg: to have data that is only available in one campaign) see [localStorage.campaign](#localstorage/campaign) Similar to [localStorage.global.getBlob](#localstorage/global/getblob) running several instances of TaleSpire at the same time on the same machine (with the same Symbiote loaded in both of them) can lead to race conditions when storing/reading data from local storage, meaning there is no guarantee for order or atomicity of operations which can lead to inconsistent data being read or unknowingly overwriting changes from the other instance.
Even global data is still scoped with the Symbiote, meaning a Symbiote can only ever read or write its own data and has no access to the data of other Symbiotes.

<br><br>
### `getBlob`

**Parameters**

none

**Returns**

string

**Failure States**

- readFailed
**Description**

Retrieves the locally stored global data for this Symbiote. Returns the same string of data as has been set with [localStorage.global.setBlob](#localstorage/global/setblob). If several instances of TaleSpire are running on the same machine race conditions between them can happen. See [localStorage.global.setBlob](#localstorage/global/setblob) for more info on that.

<br><br>
### `deleteBlob`

**Parameters**

none

**Returns**

none

**Failure States**

- deleteFailed
**Description**

Deletes the locally stored global data for this Symbiote. Does not affect campaign scoped data, to delete that, see [localStorage.campaign.deleteBlob](#localstorage/campaign/deleteblob)

<br><br>
## campaign

### `setBlob`

**Parameters**

 Name |  Type  | Description
------|--------
 str  | string

**Returns**

none

**Failure States**

- ensurePathFailed
- writeFailed
- notInCampaign
- dataTooLarge
**Description**

Stores the given string of data in a file in the Symbiote's directory. The text given can be formatted as needed; plain text, JSON, XML, etc. Text size is limited to 5MB. All [localStorage.campaign](#localstorage/campaign) calls are scoped by the campaign that is currently active, meaning there is a separate set of files per campaign. If global storage is needed (eg: to have some data available in all campaigns) see [localStorage.global](#localstorage/global) Similar to [localStorage.campaign.getBlob](#localstorage/campaign/getblob) running several instances of TaleSpire at the same time on the same machine (with the same Symbiote loaded in both of them) can lead to race conditions when storing/reading data from local storage, meaning there is no guarantee for order or atomicity of operations which can lead to inconsistent data being read or unknowingly overwriting changes from the other instance.
Campaign data is additionally scoped with the Symbiote, meaning a Symbiote can only ever read or write its own data and has no access to the data of other Symbiotes even if they are both open in the same campaign.


<br><br>
### `getBlob`

**Parameters**

none

**Returns**

string

**Failure States**

- readFailed
- notInCampaign
**Description**

Retrieves the locally stored data attached to the currently active campaign for this Symbiote. Returns the same string of data as has been set with [localStorage.campaign.setBlob](#localstorage/campaign/setblob). If several instances of TaleSpire are running on the same machine race conditions between them can happen. See [localStorage.campaign.setBlob](#localstorage/campaign/setblob) for more info on that.

<br><br>
### `deleteBlob`

**Parameters**

none

**Returns**

none

**Failure States**

- deleteFailed
- notInCampaign
**Description**

Deletes the locally stored data attached to the currently active campaign for this Symbiote. Does not affect global Symbiote data, to delete that, see [localStorage.global.deleteBlob](#localstorage/global/deleteblob)

<br><br>
# parties

## `getParties`

**Parameters**

none

**Returns**

Array[[partyFragment](#types/partyfragment)]

**Description**

Returns the IDs for all existing parties. For now only one party is supported by TaleSpire, this function will have more utility once the party system gets overhauled.

<br><br>
## `getCreaturesInParty`

**Parameters**

       Name        |     Type     | Description
-------------------|--------------
 partyFragmentOrId | fragmentOrId

**Returns**

Array[string]

**Failure States**

- unknownPartyId
**Description**

Returns all creatures (as array of creature IDs) that belong to any player (including GMs) of the specified party.

<br><br>
# picking

## `startPicking`

**Parameters**

none

**Returns**

string

**Failure States**

- couldNotSwitchToTool
- toolInUse
**Description**

Starts the Symbiote picking tool which allows the user to click on something on the board and the information (id and kind) of that something to be sent to the Symbiote that started the picking. Tool can be dismissed by the user which results in a `pickingCanceled` event from the [onPickingEvent](#subscriptions/picking/onpickingevent) event source. The picking result comes with the `pickingCompleted` event from the same event source. If another Symbiote has already started a picking operation that has not been completed or canceled by the user yet, this call will return the `toolInUse` error.

<br><br>
# players

## `whoAmI`

**Parameters**

none

**Returns**

[playerFragment](#types/playerfragment)

**Description**

Returns the player fragment of the own player (= The player that is running the Symbiote).

<br><br>
## `isMe`

**Parameters**

        Name        |     Type     | Description
--------------------|--------------
 playerFragmentOrId | fragmentOrId

**Returns**

boolean

**Description**

Returns true if the specified player ID (or player fragment) is the same player as the one running the Symbiote (= whether the player is yourself). Returns false otherwise.

<br><br>
## `getPlayersInThisCampaign`

**Parameters**

none

**Returns**

Array[[playerFragment](#types/playerfragment)]

**Description**

Returns a list of all players who are members of this campaign. This includes players who are not currently connected, as well as banned players. To see their status, use [players.getMoreInfo](#players/getmoreinfo), which shows their permissions, connected clients, etc.


<br><br>
## `getPlayersInThisBoard`

**Parameters**

none

**Returns**

Array[[playerFragment](#types/playerfragment)]

**Description**

Returns a list of all players currently connected to this board.

<br><br>
## `getMoreInfo`

**Parameters**

        Name         |        Type         | Description
---------------------|---------------------
 playerFragmentOrIds | Array[fragmentOrId]

**Returns**

Array[[playerInfo](#types/playerinfo)]

**Description**

Returns more info on the specified player. The clientsIds list in the response shows info on the clients with which the respective player is connected, but only for the same board as the own client running the Symbiote is in.

<br><br>
# rulers

## `getRulers`

**Parameters**

none

**Returns**

Array[[rulerFragment](#types/rulerfragment)]

**Description**

Returns all rulers currently active on the board or an empty array if there is none. This does not include AoE markers. For querying just your own rulers, see [rulers.getLocalRulers](#rulers/getlocalrulers).

<br><br>
## `startRuler`

**Parameters**

 Name |             Type              | Description
------|-------------------------------
 kind | [rulerKind](#types/rulerkind)

**Returns**

string

**Failure States**

- invalidRulerKind
- couldNotSwitchToTool
- toolInUse
**Description**

Selects a ruler to start measuring. Can pick any of the available ruler types by selecting its kind: "sphere", "line", "cone". Will trigger a `rulerAdded` event from the [onRulerEvent](#subscriptions/rulers/onrulerevent) event source.

<br><br>
## `getLocalRuler`

**Parameters**

none

**Returns**

[rulerFragment](#types/rulerfragment)

**Failure States**

- rulerNotFound
**Description**

Returns the ruler set by the own client or rulerNotFound if there is no active one. This does not include AoE markers. For querying all rulers, including ones from other clients, see [rulers.getRulers](#rulers/getrulers).

<br><br>
## `getMoreInfo`

**Parameters**

        Name         |        Type         | Description
---------------------|---------------------
 rulerFragmentsOrIds | Array[fragmentOrId]

**Returns**

Array[[lineRulerInfo](#types/linerulerinfo) or [sphereRulerInfo](#types/sphererulerinfo) or [coneRulerInfo](#types/conerulerinfo)]

**Description**

Returns more info on the specified ruler.

<br><br>
# slabs

## `unpack`

**Parameters**

  Name   |  Type  | Description
---------|--------
 slabStr | string

**Returns**

object

**Description**

Takes the copied slab string and unpacks it to a binary representation using JavaScript [Array Buffers](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer). Extracting their data can be done manually one byte at a time, but using [Data Views](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) can simplify a lot of the process.

<br><br>
## `pack`

**Parameters**

      Name      |  Type   | Description
----------------|---------
 slabBinary     | object 
 allowOversized | boolean

**Returns**

string

**Description**

Takes a JavaScript [Array Buffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) and packs it: First it gets compressed with gzip and then base64 encoded to get the final slab string. `allowOversized` does not need to be specified and defaults to false, which will cause the function to return an error if the slab data is larger than the `maxSlabSize` (which can be queried by [slabs.getMaxSlabSize](#slabs/getmaxslabsize)). This can be deactivated by setting this argument to true, which results in the slab string to be created regardless. TaleSpire will still not accept slabs larger than the limit, but this can be used for example for intermediate representations for other external slab tools to use.

<br><br>
## `getDataSize`

**Parameters**

  Name   |  Type  | Description
---------|--------
 slabStr | string

**Returns**

int

**Description**

Returns the data size of the slab string after base64 decoding. This is the size that is checked against the slab size limit. To get the size limit, see [slabs.getMaxSlabSize](#slabs/getmaxslabsize).

<br><br>
## `sendSlabToHand`

**Parameters**

  Name   |  Type  | Description
---------|--------
 slabStr | string

**Returns**

none

**Failure States**

- notInBoard
- clientIsNotInGmMode
- invalidSlabString
- dataOversized
- spawnFailed
**Description**

Sends the provided slab string to the hand ready to be placed by the user.

<br><br>
## `getSlabInActiveSelection`

**Parameters**

none

**Returns**

string

**Failure States**

- areaNotReady
- dataOversized
- nothingInsideSelection
- noActiveSelection
**Description**

Returns a slab created from the currently active volume selection box.

<br><br>
## `getMaxSlabSizeInBytes`

**Parameters**

none

**Returns**

int

**Description**

This returns the size in bytes that a slab can be at maximum. This size is before base64 encoding it, but after compressing it with gzip. The limit is fixed and won't change during runtime, but using this function allows Symbiotes to adapt to potentially changing limits through updates.

<br><br>
# symbiote

## `getIfThisSymbioteIsVisible`

**Parameters**

none

**Returns**

boolean

**Description**

Returns whether the Symbiote is currently visible or not. This includes the Symbiotes panel being collapsed and a Symbiote being put in the background (if it has this capability set in the manifest) when another Symbiote is loaded.

<br><br>
## `sendNotification`

**Parameters**

     Name     |  Type  | Description
--------------|--------|-------------
 title        | string | truncated if length > 150
 body         | string | truncated if length > 400
 optionalData | string | max length is 200

**Returns**

none

**Failure States**

- symbioteManifestMissingInteropId
**Description**

Sends a notification to the own client's chat/history pane. The notification is clickable to focus/open the Symbiote that has sent it. If the Symbiote has been shut down since sending - either because it's not set to run in background or because it was manually closed by the user - it will be opened and restarted.

The notification has a title and body and can be formatted similar to [chat](#chat) messages with rich text using Unity's [TextMeshPro](https://docs.unity3d.com/Packages/com.unity.textmeshpro@3.2/manual/RichText.html).
Additionally, you can optionally define extra data that is not rendered, but sent to the Symbiote via the `notificationActivated` event from the [onNotificationEvent](#subscriptions/symbiote/onnotificationevent) event source upon clicking the notification, allowing to pass some meta data about the clicked notification to the Symbiote for example to be able to tell apart clicks on different notifications.

The Symbiote needs to have an interop ID defined in its manifest for this to be accessible.

<br><br>
# sync

## `send`

**Parameters**

  Name   |     Type     | Description
---------|--------------|-------------
 message | string       | max length is 500
 target  | fragmentOrId | 

**Returns**

none

**Failure States**

- invalidTarget
- messageTooLarge
- notConnected
- symbioteManifestMissingInteropId
**Description**

Sends the text specified in `message` to the given `target` via the realtime backend. Target can be either a single client fragment or client ID (not player ID) or one of the following keywords: "board", "gms" which sends to all players on the board, or all GMs respectively. All GMs specifically sends to all clients that have GM permissions, regardless of whether they currently are or aren't in GM mode. To be able to use this function the Symbiote needs to have an interop ID set in the manifest. The message size is limited to 1kB of data. Received sync messages trigger the `syncMessageReceived` event from the [onSyncMessage](#subscriptions/sync/onsyncmessage) event source.

<br><br>
## `multiSend`

**Parameters**

         Name         |        Type         | Description
----------------------|---------------------|-------------
 message              | string              | max length is 500
 clientFragmentsOrIds | Array[fragmentOrId] | max length is 20

**Returns**

none

**Failure States**

- messageTooLarge
- notConnected
- symbioteManifestMissingInteropId
**Description**

Sends messages via the realtime backend to several clients at once. Can either be provided with an array of client fragments or array of client IDs. Useful if you want to target several clients with the same message, if you want to send the same message to all players you can instead use [sync.send](#sync/send) with the target "board". The target keywords available with [sync.send](#sync/send) don't work here. The message size is limited to 1kB of data.

<br><br>
## `getClientsConnected`

**Parameters**

none

**Returns**

Array[[clientFragment](#types/clientfragment)]

**Failure States**

- notConnected
- symbioteManifestMissingInteropId
**Description**

Returns a list of all clients that has the Symbiote with the same interop ID as the one that called the function loaded. Does not include clients that have the Symbiote installed but not open.

<br><br>
# system

## clipboard

### `setText`

**Parameters**

 Name |  Type  | Description
------|--------
 text | string

**Returns**

none

**Description**

Puts the specified text into the system clipboard for the user to paste.

<br><br>
# units

## `getDistanceUnitsForThisCampaign`

**Parameters**

none

**Returns**

[distanceUnit](#types/distanceunit)

**Description**

Returns the distance units for rulers that have been set for the campaign.

<br><br>
# urls

## `submit`

**Parameters**

  Name  |  Type  | Description
--------|--------
 urlStr | string

**Returns**

none

**Failure States**

- urlInvalid
- urlRejected
**Description**

Passes a `talespire://` URL to TaleSpire. Behaves mostly identical to simply clicking a link in the browser (or opening it with `window.open`), but instead of going through the TaleSpireUrlRelay program it goes directly to TaleSpire.

This has the advantage of being a direct connection, so is more efficient with less potential for delays. It also reliably targets the correct client if several are open at once which going through the UrlRelay does not. Additionally it is not limited to opening one link per user interaction in web view Symbiotes, because of Chrome's link opening/pop-up prevention policies.

<br><br>
## `createUrlPrefixForThisSymbiote`

**Parameters**

none

**Returns**

string

**Failure States**

- symbioteManifestMissingInteropId
**Description**

Symbiotes can receive information from outside by using `talespire://symbiote/` URLs. This function returns the start of the URL: `talespire://symbiote/<system_segment>/`, where the `system_segment` is data used by TaleSpire to properly deliver the messages to the right Symbiote. The transmitted information is the "user segment" which is to be appended to the returned URL string like so: `talespire://symbiote/<system_segment>/<user_segment>`

The interop ID has to be set in the manifest for this to work.
The URL prefix is stable (=unchanging) for as long as the interop ID remains the same.


<br><br>

# Subscriptions

## urls


### `onUrlMessage`

**Events**

* [urlMessageReceived](#types/urlmessagereceived)

**Description**

The `urlMessageReceived` event gets triggered whenever your Symbiote receives a `talespire://symbiotes/` URL via the TaleSpire URL Relay. Payload contains the data attached to the URL after the prefix. For example if a user clicks the url `talespire://symbiote/1234567890/test` the Symbiote that is prefixed by `1234567890` receives the message "test". If the Symbiote is not running when this message is received it will be loaded and then receives the message. If the Symbiote has the capability to run in background set in the manifest it will stay loaded, if not, it will be shutdown after delivery of the message.

<br><br>
## rulers


### `onRulerEvent`

**Events**

* [rulerAdded](#types/ruleradded)

* [rulerRemoved](#types/rulerremoved)

* [rulerResult](#types/rulerresult)

**Description**

The `rulerAdded` event is triggered when a new ruler measurement is started by a client on the same board. This only includes an ID for the ruler for later reference.

`rulerResult` triggers whenever measuring with a ruler is finished and the final positions are set on the board. This includes information on all the positions of the ruler allowing for example total length of a line ruler to be calculated - or more interesting things like only vertical height difference.

`rulerRemoved` triggers whenever a ruler is either removed from the board after finishing the measurement or if it is dismissed while measuring.

<br><br>
## chat


### `onChatEvent`

**Events**

* [chatMessageReceived](#types/chatmessagereceived)

**Description**

The `chatMessage` event triggers whenever a chat message is received by your client. Includes messages sent by the own client and messages sent through the Symbiotes API, including your own Symbiote.

The information contains the message itself, who sent it from where and under what name it was sent

<br><br>
## creatures


### `onCreatureStateChange`

**Events**

* [creatureAdded](#types/creatureadded)

* [creatureRemoved](#types/creatureremoved)

* [creatureIsUniqueChanged](#types/creatureisuniquechanged)

* [creatureNameChanged](#types/creaturenamechanged)

* [creatureLinkChanged](#types/creaturelinkchanged)

* [creatureLocationChanged](#types/creaturelocationchanged)

* [creatureMorphsChanged](#types/creaturemorphschanged)

* [creatureActiveMorphChanged](#types/creatureactivemorphchanged)

* [creatureHpChanged](#types/creaturehpchanged)

* [creatureStatsChanged](#types/creaturestatschanged)

* [creatureTorchStateChanged](#types/creaturetorchstatechanged)

* [creatureExplicitlyHiddenStateChanged](#types/creatureexplicitlyhiddenstatechanged)

* [creatureFlyingStateChanged](#types/creatureflyingstatechanged)

* [creatureActivePersistentEmotesChanged](#types/creatureactivepersistentemoteschanged)

* [creatureOwnersChanged](#types/creatureownerschanged)

**Description**

The `onCreatureStateChange` event source provides access to a whole host of creature related events. Your handling function can listen to any number of them to only see what it cares about. Creature events are board-wide and unfiltered, so if you for example want to create a Symbiote that keeps track of all creatures in the initiative queue, it needs to check whether the event is about a creature that is actually in the queue.

Unique creatures can trigger events even when they are not on the same board as they are stored campaign-wide.

The names of the events should be self-explanatory for when they trigger.

<br><br>
## campaigns

### current


#### `onInfoChanged`

**Events**

* [campaignInfoChanged](#types/campaigninfochanged)

**Description**

The `campaignInfoChanged` event triggers when the campaign name, description or default board have been edited.

<br><br>

#### `onBoardEvent`

**Events**

* [boardAdded](#types/boardadded)

* [boardInfoChanged](#types/boardinfochanged)

* [boardRemoved](#types/boardremoved)

**Description**

The `boardAdded` and `boardRemoved` events trigger whenever a board gets added to or removed from the current campaign respectively.

`boardInfoChanged` triggers when the name or description of a board is edited.

<br><br>

#### `onSettingsChanged`

**Events**

* [distanceUnitsChanged](#types/distanceunitschanged)

* [statNamesChanged](#types/statnameschanged)

**Description**

The `distanceUnitsChanged` event is triggered whenever the ruler distance units get modified in the campaign settings.
The `statNamesChanged` event is triggered whenever the aliases/names for any of the generic stats in the campaign get changed either by hand or by importing them from a `talespire://stat-names/` link.

<br><br>
## sync


### `onSyncMessage`

**Events**

* [syncMessageReceived](#types/syncmessagereceived)

**Description**

The `syncMessageReceived` event gets triggered whenever a sync message gets received from the realtime backend. Only messages from the same Symbiote (= Symbiote with the same interop ID) can be received.

<br><br>

### `onClientEvent`

**Events**

* [clientConnected](#types/clientconnected)

* [clientDisconnected](#types/clientdisconnected)

**Description**

The `clientConnected` event gets triggered whenever a client opens a Symbiote with the same interop ID as yours or joins the same board with it already open. This event also triggers for your own client opening the Symbiote.
The `clientDisconnected` event gets triggered whenever a client that has a Symbiote with the same interop ID open leaves the board that your clients' Symbiote is open in *or* closes that Symbiote.

<br><br>
## dice


### `onRollResults`

**Events**

* [rollResults](#types/rollresults)

* [rollRemoved](#types/rollremoved)

**Description**

The `rollResults` event is triggered whenever any user on the board rolls any dice and a result is received from that. The result contains the rollId (and clientId of the client rolling) which can be checked against the rollId that is returned from [dice.putDiceInTray](#dice/putdiceintray) if you want to filter out rolls the Symbiote created by itself (or the own/a specific other client).

The `rollRemoved` event is triggered either when a roll that has previously been put in the tray by your Symbiote is dismissed instead of being rolled or when any dice on the board are deleted. This allows Symbiotes to stop keeping track of certain rollIds when their accompanying dice were either never rolled or have since been deleted.

<br><br>
## slabs


### `onSlabCopied`

**Events**

* [slabCopied](#types/slabcopied)

**Description**

The `slabCopied` event triggers whenever the own user client (the one that is running the Symbiote) is copying a slab and contains the slab data as well as a notice if the copied slab contained too much data to be converted to a slab string.

<br><br>
## contentPacks


### `onContentPackChange`

**Events**

* [contentPackAdded](#types/contentpackadded)

* [contentPackRemoved](#types/contentpackremoved)

**Description**

The `contentPackAdded` and `contentPackRemoved` events trigger whenever a content pack gets added to or removed from the current campaign respectively. As of right now all content packs are loaded on startup, this is in preparation of asset modding which will allow modded content packs to be loaded and unloaded during runtime.

<br><br>
## clients


### `onClientEvent`

**Events**

* [clientJoinedBoard](#types/clientjoinedboard)

* [clientLeftBoard](#types/clientleftboard)

* [clientModeChanged](#types/clientmodechanged)

**Description**

The `clientJoinedBoard` and `clientLeftBoard` events trigger for a game client connecting to and disconnecting from the same board as the Symbiote is in. A game client does not equal to a player as one player can be connected to the same campaign/board (or different ones) with several clients at once. See [players.onBoardPlayerEvent](#players/onboardplayerevent) if you care about only the player events and not about their individual clients.
The join and leave events also trigger for the own client when switching boards, allowing to detect board switches.

`clientModeChanged` triggers when the client mode is switched from player to GM or vice versa. This specifically refers to the current view mode it is in, not the canGM permission. For that, see [players.getMoreInfo](#players/getmoreinfo).

<br><br>
## symbiote


### `onVisibilityEvent`

**Events**

* [hasBecomeVisible](#types/hasbecomevisible)

* [hasBecomeHidden](#types/hasbecomehidden)

**Description**

The `hasBecomeVisible` event is triggered when the Symbiote comes back into the foreground. This happens when it is initially loaded, returns from the background due to another Symbiote being open in "front" of it (only possible if this Symbiote has the `runInBackground` capability) or if the Symbiote side panel was collapsed and has been reopened.

`hasBecomeHidden` triggers more or less opposite of that: If a Symbiote is being shut down, another one is opened in front of it or if the side panel gets collapsed.

<br><br>

### `onStateChangeEvent`

**Events**

* [hasInitialized](#types/hasinitialized)

* [willEnterBackground](#types/willenterbackground)

* [hasEnteredForeground](#types/hasenteredforeground)

* [willShutdown](#types/willshutdown)

**Description**

The `hasInitialized` event is triggered once the Symbiote API has been successfully injected and the connection to TaleSpire has been started. If something went wrong, this will still trigger after the `initTimeout` specified in the manifest.

`willEnterBackground` and `hasEnteredForeground` only trigger for Symbiotes that have the `runInBackground` capability set. `willEnterBackground` is triggered whenever another Symbiote is started and this one is now not visible anymore, while `hasEnteredForeground` is triggered whenever the Symbiote regains focus.

`willShutdown` is triggered when TaleSpire is about to shut down the Symbiote either due to it going in the background without having the `runInBackground` capability or by being closed manually by the user. Additionally, we reserve the right to shut down any Symbiote at any point for performance or stability reasons. This event is a "best effort" event and not guaranteed to be triggered in time before shutdown, so there shouldn't be any crucial tasks that only get executed on shutdown.

<br><br>

### `onNotificationEvent`

**Events**

* [notificationActivated](#types/notificationactivated)

**Description**

The `notificationActivated` event is triggered when the user clicks on a notification that was sent by a Symbiote. The payload of the event consists of the `optionalData` argument specified when [sending](#symbiote/sendnotification) the notification.
Only the Symbiote that sent the notification that was clicked on receives this event.
If the user clicks on the notification while the Symbiote is closed, the Symbiote will be launched and the event will be delivered once initialization has completed.

<br><br>
## players


### `onCampaignPlayerEvent`

**Events**

* [playerJoinedCampaign](#types/playerjoinedcampaign)

* [playerLeftCampaign](#types/playerleftcampaign)

* [playerRightsChanged](#types/playerrightschanged)

**Description**

The `playerJoinedCampaign` and `playerLeftCampaign` events are triggered when a player joins or leaves *the campaign*. This does not need to coincide with the player actually being online or offline, but instead is referring to the list of players in the campaign. As of right now `playerJoinedCampaign` can only trigger as consequence of a player actually connecting to a campaign, but internally they are handled separately.

`playerRightsChanged` is triggered when the permissions are updated, meaning when a user is for example promoted from player to GM, or when they get banned.

<br><br>

### `onBoardPlayerEvent`

**Events**

* [playerJoinedBoard](#types/playerjoinedboard)

* [playerLeftBoard](#types/playerleftboard)

**Description**

The `playerJoinedBoard` and `playerLeftBoard` events get triggered whenever a player joins or leaves the board that the Symbiote is open in. Because players can have several clients connected at once, the join event is triggered when the *first* client of a player joins and the leave event when the *last* client of a player leaves. The join and leave events also trigger for yourself when switching boards, allowing to detect board switches - however, if several clients from the same player are connected this will not trigger, so using the join and leave events from the [clients.onClientEvent](#clients/onclientevent) event source is preferable instead.

<br><br>
## initiative


### `onInitiativeEvent`

**Events**

* [initiativeUpdated](#types/initiativeupdated)

**Description**

The `initiativeUpdated` event is triggered when in initiative mode and the turn is moved forwards/backwards or if the turn queue is edited by adding or removing entries.

<br><br>
## picking


### `onPickingEvent`

**Events**

* [pickingCompleted](#types/pickingcompleted)

* [pickingCanceled](#types/pickingcanceled)

**Description**

The `pickingCompleted` event is triggered when a Symbiote picking (initiated by [picking.startPicking](#picking/startpicking)) has been finished by the user. It includes information on what has been picked, as well as the picking ID previously returned by the [picking.startPicking](#picking/startpicking) command.

The `pickingCanceled` event is triggered when the user cancels the picking operation by dismissing the tool (right click or pressing Escape).

<br><br>
## talespire


# Types

## `boardAdded`
 Name  |                 Type
-------|---------------------------------------
 board | [boardFragment](#types/boardfragment)
*Used By*

* subscription: [onBoardEvent](#onBoardEvent)

## `boardFragment`
 Name |  Type
------|--------
 id   | string
 name | string
*Used By*

* call: [boards.getBoardsInThisCampaign](#boards/getBoardsInThisCampaign)

* call: [boards.whereAmI](#boards/whereAmI)

* type: [boardAdded](#types/boardadded)

## `boardRemoved`
  Name   |  Type
---------|--------
 boardId | string
*Used By*

* subscription: [onBoardEvent](#onBoardEvent)

## `boardInfoChanged`
 Name |             Type
------|-------------------------------
 info | [boardInfo](#types/boardinfo)
*Used By*

* subscription: [onBoardEvent](#onBoardEvent)

## `boardInfo`
    Name     |  Type
-------------|--------
 id          | string
 campaignId  | string
 name        | string
 description | string
*Used By*

* call: [boards.getMoreInfo](#boards/getMoreInfo)

* type: [boardInfoChanged](#types/boardinfochanged)

## `playerJoinedCampaign`
  Name  |                  Type
--------|-----------------------------------------
 player | [playerFragment](#types/playerfragment)
*Used By*

* subscription: [onCampaignPlayerEvent](#onCampaignPlayerEvent)

## `playerFragment`
 Name |  Type
------|--------
 id   | string
 name | string
*Used By*

* call: [players.getPlayersInThisBoard](#players/getPlayersInThisBoard)

* call: [players.getPlayersInThisCampaign](#players/getPlayersInThisCampaign)

* call: [players.whoAmI](#players/whoAmI)

* type: [clientFragment](#types/clientfragment)

* type: [clientInfo](#types/clientinfo)

* type: [playerJoinedBoard](#types/playerjoinedboard)

* type: [playerJoinedCampaign](#types/playerjoinedcampaign)

* type: [playerLeftBoard](#types/playerleftboard)

* type: [playerRightsChanged](#types/playerrightschanged)

## `playerLeftCampaign`
   Name   |  Type
----------|--------
 playerId | string
*Used By*

* subscription: [onCampaignPlayerEvent](#onCampaignPlayerEvent)

## `playerRightsChanged`
  Name  |                  Type
--------|-----------------------------------------
 player | [playerFragment](#types/playerfragment)
 rights | [playerRights](#types/playerrights)
*Used By*

* subscription: [onCampaignPlayerEvent](#onCampaignPlayerEvent)

## `playerRights`
  Name   |  Type
---------|---------
 isOwner | boolean
 canPlay | boolean
 canGm   | boolean
*Used By*

* type: [playerInfo](#types/playerinfo)

* type: [playerRightsChanged](#types/playerrightschanged)

## `playerJoinedBoard`
  Name  |                  Type
--------|-----------------------------------------
 player | [playerFragment](#types/playerfragment)
*Used By*

* subscription: [onBoardPlayerEvent](#onBoardPlayerEvent)

## `playerLeftBoard`
  Name  |                  Type
--------|-----------------------------------------
 player | [playerFragment](#types/playerfragment)
*Used By*

* subscription: [onBoardPlayerEvent](#onBoardPlayerEvent)

## `campaignFragment`
 Name |  Type
------|--------
 id   | string
 name | string
*Used By*

* call: [campaigns.whereAmI](#campaigns/whereAmI)

## `campaignInfo`
      Name      |  Type
----------------|--------
 id             | string
 name           | string
 description    | string
 defaultBoardId | string
*Used By*

* call: [campaigns.getMoreInfoAboutCurrentCampaign](#campaigns/getMoreInfoAboutCurrentCampaign)

* type: [campaignInfoChanged](#types/campaigninfochanged)

## `campaignInfoChanged`
 Name |                Type
------|-------------------------------------
 info | [campaignInfo](#types/campaigninfo)
*Used By*

* subscription: [onInfoChanged](#onInfoChanged)

## `clientFragment`
  Name  |                  Type
--------|-----------------------------------------
 id     | string
 player | [playerFragment](#types/playerfragment)
*Used By*

* call: [clients.getClientsInThisBoard](#clients/getClientsInThisBoard)

* call: [clients.whoAmI](#clients/whoAmI)

* call: [sync.getClientsConnected](#sync/getClientsConnected)

* type: [clientConnected](#types/clientconnected)

* type: [clientJoinedBoard](#types/clientjoinedboard)

* type: [clientLeftBoard](#types/clientleftboard)

* type: [clientModeChanged](#types/clientmodechanged)

* type: [rulerFragment](#types/rulerfragment)

* type: [syncMessageReceived](#types/syncmessagereceived)

## `clientInfo`
    Name    |                  Type
------------|-----------------------------------------
 id         | string
 clientMode | [clientMode](#types/clientmode)
 player     | [playerFragment](#types/playerfragment)
*Used By*

* call: [clients.getMoreInfo](#clients/getMoreInfo)

## `clientMode`
   Name    | Value
-----------|-------
 spectator | 1
 player    | 2
 gm        | 3
*Used By*

* type: [clientInfo](#types/clientinfo)

* type: [clientModeChanged](#types/clientmodechanged)

## `playerInfo`
    Name    |                Type
------------|-------------------------------------
 id         | string
 name       | string
 clientsIds | Array[string]
 rights     | [playerRights](#types/playerrights)
*Used By*

* call: [players.getMoreInfo](#players/getMoreInfo)

## `syncMessageReceived`
    Name    |                  Type
------------|-----------------------------------------
 str        | string
 fromClient | [clientFragment](#types/clientfragment)
*Used By*

* subscription: [onSyncMessage](#onSyncMessage)

## `urlMessageReceived`
 Name |  Type
------|--------
 str  | string
*Used By*

* subscription: [onUrlMessage](#onUrlMessage)

## `rollDescriptor`
 Name |  Type
------|--------
 name | string
 roll | string
*Used By*

* call: [dice.makeRollDescriptors](#dice/makeRollDescriptors)

* call: [dice.putDiceInTray](#dice/putDiceInTray)

## `rollResults`
     Name      |                        Type
---------------|----------------------------------------------------
 rollId        | string
 clientId      | string
 resultsGroups | Array[[rollResultsGroup](#types/rollresultsgroup)]
 gmOnly        | boolean
 quiet         | boolean
*Used By*

* subscription: [onRollResults](#onRollResults)

## `rollResultsGroup`
  Name  |                                                          Type
--------|-------------------------------------------------------------------------------------------------------------------------
 name   | string
 result | [rollResultsOperation](#types/rollresultsoperation) or [rollResult](#types/rollresult) or [rollValue](#types/rollvalue)
*Used By*

* call: [dice.evaluateDiceResultsGroup](#dice/evaluateDiceResultsGroup)

* call: [dice.sendDiceResult](#dice/sendDiceResult)

* type: [rollResults](#types/rollresults)

## `rollResultsOperation`
   Name   |                                                              Type
----------|--------------------------------------------------------------------------------------------------------------------------------
 operator | string
 operands | Array[[rollResultsOperation](#types/rollresultsoperation) or [rollResult](#types/rollresult) or [rollValue](#types/rollvalue)]
*Used By*

* type: [rollResultsGroup](#types/rollresultsgroup)

## `rollResult`
  Name   |    Type
---------|------------
 kind    | string
 results | Array[int]
*Used By*

* type: [rollResultsGroup](#types/rollresultsgroup)

## `rollValue`
 Name  | Type
-------|------
 value | int
*Used By*

* type: [rollResultsGroup](#types/rollresultsgroup)

## `rollRemoved`
  Name  |  Type
--------|--------
 rollId | string
*Used By*

* subscription: [onRollResults](#onRollResults)

## `slabCopied`
   Name   |                    Type
----------|---------------------------------------------
 slab     | string
 status   | [slabCopiedStatus](#types/slabcopiedstatus)
 dataSize | int
*Used By*

* subscription: [onSlabCopied](#onSlabCopied)

## `slabCopiedStatus`
   Name    | Value
-----------|-------
 success   | 4
 oversized | 5
*Used By*

* type: [slabCopied](#types/slabcopied)

## `contentPackAdded`
     Name      |  Type
---------------|--------
 contentPackId | string
 optionalName  | string
*Used By*

* subscription: [onContentPackChange](#onContentPackChange)

## `contentPackRemoved`
     Name      |  Type
---------------|--------
 contentPackId | string
*Used By*

* subscription: [onContentPackChange](#onContentPackChange)

## `contentPackFragment`
     Name     |  Type
--------------|--------
 id           | string
 optionalName | string
*Used By*

* call: [contentPacks.getContentPacks](#contentPacks/getContentPacks)

## `contentPackInfo`
     Name     |                                    Type
--------------|----------------------------------------------------------------------------
 id           | string
 optionalName | string
 tiles        | Array[[contentPackPlaceableElement](#types/contentpackplaceableelement)]
 props        | Array[[contentPackPlaceableElement](#types/contentpackplaceableelement)]
 creatures    | Array[[contentPackCreatureElement](#types/contentpackcreatureelement)]
 music        | Array[[contentPackMusicElement](#types/contentpackmusicelement)]
 iconsAtlases | Array[[contentPackIconsAtlasElement](#types/contentpackiconsatlaselement)]
*Used By*

* call: [contentPacks.findBoardObjectInPacks](#contentPacks/findBoardObjectInPacks)

* call: [contentPacks.getMoreInfo](#contentPacks/getMoreInfo)

* type: [boardObjectFindResult](#types/boardobjectfindresult)

## `contentPackPlaceableElement`
        Name         |                             Type
---------------------|--------------------------------------------------------------
 id                  | string
 name                | string
 isDeprecated        | boolean
 groupTag            | string
 tags                | Array[string]
 assets              | Array[[contentPackLoaderData](#types/contentpackloaderdata)]
 isInteractable      | boolean
 colliderBoundsBound | [bounds](#types/bounds)
 icon                | [contentPackIconElement](#types/contentpackiconelement)
*Used By*

* type: [boardObjectFindResult](#types/boardobjectfindresult)

* type: [contentPackInfo](#types/contentpackinfo)

## `contentPackCreatureElement`
     Name     |                          Type
--------------|---------------------------------------------------------
 id           | string
 name         | string
 isDeprecated | boolean
 groupTag     | string
 tags         | Array[string]
 miniAsset    | [contentPackLoaderData](#types/contentpackloaderdata)
 baseAsset    | [contentPackLoaderData](#types/contentpackloaderdata)
 defaultScale | number
 icon         | [contentPackIconElement](#types/contentpackiconelement)
*Used By*

* type: [boardObjectFindResult](#types/boardobjectfindresult)

* type: [contentPackInfo](#types/contentpackinfo)

## `contentPackMusicElement`
 Name  |                         Type
-------|-------------------------------------------------------
 asset | [contentPackLoaderData](#types/contentpackloaderdata)
*Used By*

* type: [contentPackInfo](#types/contentpackinfo)

## `contentPackIconsAtlasElement`
    Name    |                   Type
------------|-------------------------------------------
 path       | string
 resolution | [atlasResolution](#types/atlasresolution)
*Used By*

* type: [contentPackInfo](#types/contentpackinfo)

## `contentPackLoaderData`
   Name    |  Type
-----------|--------
 bundleId  | string
 assetName | string
*Used By*

* type: [contentPackCreatureElement](#types/contentpackcreatureelement)

* type: [contentPackMusicElement](#types/contentpackmusicelement)

* type: [contentPackPlaceableElement](#types/contentpackplaceableelement)

## `bounds`
  Name  |            Type
--------|-----------------------------
 center | [position](#types/position)
 width  | float
 height | float
 depth  | float
*Used By*

* type: [contentPackPlaceableElement](#types/contentpackplaceableelement)

## `contentPackIconElement`
    Name    |        Type
------------|---------------------
 atlasIndex | int
 region     | [rect](#types/rect)
*Used By*

* type: [contentPackCreatureElement](#types/contentpackcreatureelement)

* type: [contentPackPlaceableElement](#types/contentpackplaceableelement)

## `atlasResolution`
  Name  | Type
--------|------
 width  | int
 height | int
*Used By*

* type: [contentPackIconsAtlasElement](#types/contentpackiconsatlaselement)

## `rect`
  Name  | Type
--------|-------
 x      | float
 y      | float
 width  | float
 height | float
*Used By*

* type: [contentPackIconElement](#types/contentpackiconelement)

## `position`
 Name  |  Type
-------|--------
 locId | number
 x     | float
 y     | float
 z     | float
*Used By*

* type: [bookmark](#types/bookmark)

* type: [bounds](#types/bounds)

* type: [coneRulerInfo](#types/conerulerinfo)

* type: [creatureInfo](#types/creatureinfo)

* type: [creatureLocationChanged](#types/creaturelocationchanged)

* type: [lineRulerInfo](#types/linerulerinfo)

* type: [sphereRulerInfo](#types/sphererulerinfo)

## `creatureFragment`
 Name |  Type
------|--------
 id   | string
*Used By*

* call: [creatures.getCreaturesOwnedByPlayer](#creatures/getCreaturesOwnedByPlayer)

* call: [creatures.getSelectedCreatures](#creatures/getSelectedCreatures)

* call: [creatures.getUniqueCreaturesInThisCampaign](#creatures/getUniqueCreaturesInThisCampaign)

* type: [creatureAdded](#types/creatureadded)

## `creatureInfo`
            Name             |                    Type
-----------------------------|--------------------------------------------
 id                          | string
 isUnique                    | boolean
 name                        | string
 nameSet                     | boolean
 link                        | string
 position                    | [position](#types/position)
 rotation                    | [eulerRotation](#types/eulerrotation)
 boardId                     | string
 morphs                      | Array[[morph](#types/morph)]
 activeMorphIndex            | int
 hp                          | [creatureStat](#types/creaturestat)
 stats                       | Array[[creatureStat](#types/creaturestat)]
 torchIsOn                   | boolean
 isExplicitlyHidden          | boolean
 isFlying                    | boolean
 idsOfActivePersistentEmotes | Array[string]
 ownerIds                    | Array[string]
*Used By*

* call: [creatures.createBlueprint](#creatures/createBlueprint)

* call: [creatures.getMoreInfo](#creatures/getMoreInfo)

## `eulerRotation`
 Name | Type
------|-------
 x    | float
 y    | float
 z    | float
*Used By*

* type: [creatureInfo](#types/creatureinfo)

* type: [creatureLocationChanged](#types/creaturelocationchanged)

## `morph`
     Name     |  Type
--------------|--------
 boardAssetId | string
 scale        | float
*Used By*

* type: [creatureInfo](#types/creatureinfo)

* type: [creatureMorphsChanged](#types/creaturemorphschanged)

## `creatureStat`
 Name  |  Type
-------|--------
 name  | string
 value | float
 max   | float
*Used By*

* type: [creatureHpChanged](#types/creaturehpchanged)

* type: [creatureInfo](#types/creatureinfo)

* type: [creatureStatsChanged](#types/creaturestatschanged)

## `creatureIsUniqueChanged`
   Name   |  Type
----------|---------
 id       | string
 isUnique | boolean
*Used By*

* subscription: [onCreatureStateChange](#onCreatureStateChange)

## `creatureNameChanged`
  Name   |  Type
---------|---------
 id      | string
 name    | string
 nameSet | boolean
*Used By*

* subscription: [onCreatureStateChange](#onCreatureStateChange)

## `creatureLinkChanged`
 Name |  Type
------|--------
 id   | string
 link | string
*Used By*

* subscription: [onCreatureStateChange](#onCreatureStateChange)

## `creatureLocationChanged`
   Name   |                 Type
----------|---------------------------------------
 id       | string
 boardId  | string
 position | [position](#types/position)
 rotation | [eulerRotation](#types/eulerrotation)
*Used By*

* subscription: [onCreatureStateChange](#onCreatureStateChange)

## `creatureMorphsChanged`
  Name  |             Type
--------|------------------------------
 id     | string
 morphs | Array[[morph](#types/morph)]
*Used By*

* subscription: [onCreatureStateChange](#onCreatureStateChange)

## `creatureActiveMorphChanged`
       Name       |  Type
------------------|--------
 id               | string
 activeMorphIndex | int
*Used By*

* subscription: [onCreatureStateChange](#onCreatureStateChange)

## `creatureHpChanged`
 Name |                Type
------|-------------------------------------
 id   | string
 hp   | [creatureStat](#types/creaturestat)
*Used By*

* subscription: [onCreatureStateChange](#onCreatureStateChange)

## `creatureStatsChanged`
 Name  |                    Type
-------|--------------------------------------------
 id    | string
 stats | Array[[creatureStat](#types/creaturestat)]
*Used By*

* subscription: [onCreatureStateChange](#onCreatureStateChange)

## `creatureTorchStateChanged`
   Name    |  Type
-----------|---------
 id        | string
 torchIsOn | boolean
*Used By*

* subscription: [onCreatureStateChange](#onCreatureStateChange)

## `creatureExplicitlyHiddenStateChanged`
        Name        |  Type
--------------------|---------
 id                 | string
 isExplicitlyHidden | boolean
*Used By*

* subscription: [onCreatureStateChange](#onCreatureStateChange)

## `creatureFlyingStateChanged`
   Name   |  Type
----------|---------
 id       | string
 isFlying | boolean
*Used By*

* subscription: [onCreatureStateChange](#onCreatureStateChange)

## `creatureActivePersistentEmotesChanged`
            Name             |     Type
-----------------------------|---------------
 id                          | string
 idsOfActivePersistentEmotes | Array[string]
*Used By*

* subscription: [onCreatureStateChange](#onCreatureStateChange)

## `creatureOwnersChanged`
   Name   |     Type
----------|---------------
 id       | string
 ownerIds | Array[string]
*Used By*

* subscription: [onCreatureStateChange](#onCreatureStateChange)

## `creatureAdded`
   Name   |                    Type
----------|---------------------------------------------
 creature | [creatureFragment](#types/creaturefragment)
*Used By*

* subscription: [onCreatureStateChange](#onCreatureStateChange)

## `creatureRemoved`
 Name |  Type
------|--------
 id   | string
*Used By*

* subscription: [onCreatureStateChange](#onCreatureStateChange)

## `initiativeUpdated`
 Name  |                   Type
-------|-------------------------------------------
 queue | [initiativeQueue](#types/initiativequeue)
*Used By*

* subscription: [onInitiativeEvent](#onInitiativeEvent)

## `initiativeQueue`
      Name       |                          Type
-----------------|--------------------------------------------------------
 items           | Array[[initiativeTurnItem](#types/initiativeturnitem)]
 activeItemIndex | int
*Used By*

* call: [initiative.getQueue](#initiative/getQueue)

* type: [initiativeUpdated](#types/initiativeupdated)

## `initiativeTurnItem`
 Name |                          Type
------|---------------------------------------------------------
 id   | string
 name | string
 kind | [initiativeTurnItemKind](#types/initiativeturnitemkind)
*Used By*

* type: [initiativeQueue](#types/initiativequeue)

## `initiativeTurnItemKind`
   Name   | Value
----------|-------
 creature | 6
*Used By*

* type: [initiativeTurnItem](#types/initiativeturnitem)

## `partyFragment`
 Name |  Type
------|--------
 id   | string
*Used By*

* call: [parties.getParties](#parties/getParties)

## `clientJoinedBoard`
  Name  |                  Type
--------|-----------------------------------------
 client | [clientFragment](#types/clientfragment)
*Used By*

* subscription: [onClientEvent](#onClientEvent)

## `clientLeftBoard`
  Name  |                  Type
--------|-----------------------------------------
 client | [clientFragment](#types/clientfragment)
*Used By*

* subscription: [onClientEvent](#onClientEvent)

## `clientModeChanged`
    Name    |                  Type
------------|-----------------------------------------
 client     | [clientFragment](#types/clientfragment)
 clientMode | [clientMode](#types/clientmode)
*Used By*

* subscription: [onClientEvent](#onClientEvent)

## `bookmark`
   Name   |            Type
----------|-----------------------------
 id       | string
 name     | string
 position | [position](#types/position)
 boardId  | string
*Used By*

* call: [bookmarks.getBookmarksInThisBoard](#bookmarks/getBookmarksInThisBoard)

* call: [bookmarks.getBookmarksInThisCampaign](#bookmarks/getBookmarksInThisCampaign)

## `distanceUnit`
     Name      |  Type
---------------|--------
 name          | string
 numberPerTile | float
*Used By*

* call: [units.getDistanceUnitsForThisCampaign](#units/getDistanceUnitsForThisCampaign)

* type: [distanceUnitsChanged](#types/distanceunitschanged)

## `lineRulerInfo`
    Name     |                Type
-------------|------------------------------------
 id          | string
 beingEdited | boolean
 positions   | Array[[position](#types/position)]
*Used By*

* call: [rulers.getMoreInfo](#rulers/getMoreInfo)

* type: [rulerResult](#types/rulerresult)

## `sphereRulerInfo`
     Name      |            Type
---------------|-----------------------------
 id            | string
 beingEdited   | boolean
 startPosition | [position](#types/position)
 endPosition   | [position](#types/position)
*Used By*

* call: [rulers.getMoreInfo](#rulers/getMoreInfo)

* type: [rulerResult](#types/rulerresult)

## `coneRulerInfo`
     Name      |            Type
---------------|-----------------------------
 id            | string
 beingEdited   | boolean
 startPosition | [position](#types/position)
 endPosition   | [position](#types/position)
 angle         | float
*Used By*

* call: [rulers.getMoreInfo](#rulers/getMoreInfo)

* type: [rulerResult](#types/rulerresult)

## `distanceUnitsChanged`
 Name  |                Type
-------|-------------------------------------
 units | [distanceUnit](#types/distanceunit)
*Used By*

* subscription: [onSettingsChanged](#onSettingsChanged)

## `statNamesChanged`
   Name    |     Type
-----------|---------------
 statNames | Array[string]
*Used By*

* subscription: [onSettingsChanged](#onSettingsChanged)

## `pickingCanceled`
 Name |  Type
------|--------
 id   | string
*Used By*

* subscription: [onPickingEvent](#onPickingEvent)

## `pickingCompleted`
     Name     |                   Type
--------------|-------------------------------------------
 id           | string
 kindOfPicked | [pickedThingKind](#types/pickedthingkind)
 idOfPicked   | string
*Used By*

* subscription: [onPickingEvent](#onPickingEvent)

## `pickedThingKind`
   Name   | Value
----------|-------
 unknown  | 7
 tile     | 8
 prop     | 9
 creature | 6
*Used By*

* type: [pickingCompleted](#types/pickingcompleted)

## `rulerKind`
  Name  | Value
--------|-------
 sphere | 10
 cone   | 11
 line   | 12
*Used By*

* call: [rulers.startRuler](#rulers/startRuler)

## `rulerFragment`
  Name  |                  Type
--------|-----------------------------------------
 id     | string
 client | [clientFragment](#types/clientfragment)
*Used By*

* call: [rulers.getLocalRuler](#rulers/getLocalRuler)

* call: [rulers.getRulers](#rulers/getRulers)

## `rulerAdded`
  Name   |  Type
---------|--------
 rulerId | string
*Used By*

* subscription: [onRulerEvent](#onRulerEvent)

## `rulerRemoved`
  Name   |  Type
---------|--------
 rulerId | string
*Used By*

* subscription: [onRulerEvent](#onRulerEvent)

## `rulerResult`
 Name  |                                                            Type
-------|-----------------------------------------------------------------------------------------------------------------------------
 ruler | [lineRulerInfo](#types/linerulerinfo) or [sphereRulerInfo](#types/sphererulerinfo) or [coneRulerInfo](#types/conerulerinfo)
*Used By*

* subscription: [onRulerEvent](#onRulerEvent)

## `hasBecomeVisible`
*Type has no fields*

## `hasBecomeHidden`
*Type has no fields*

## `willEnterBackground`
*Type has no fields*

## `hasEnteredForeground`
*Type has no fields*

## `hasInitialized`
*Type has no fields*

## `willShutdown`
*Type has no fields*

## `boardObjectFindResult`
      Name       |                                                                 Type
-----------------|--------------------------------------------------------------------------------------------------------------------------------------
 contentPackInfo | [contentPackInfo](#types/contentpackinfo)
 kind            | [boardObjectKind](#types/boardobjectkind)
 boardObject     | [contentPackPlaceableElement](#types/contentpackplaceableelement) or [contentPackCreatureElement](#types/contentpackcreatureelement)
*Used By*

* call: [contentPacks.findBoardObjectInPacks](#contentPacks/findBoardObjectInPacks)

## `boardObjectKind`
   Name   | Value
----------|-------
 tile     | 8
 prop     | 9
 creature | 6
*Used By*

* type: [boardObjectFindResult](#types/boardobjectfindresult)

## `chatMessageReceived`
      Name       |                  Type
-----------------|-----------------------------------------
 senderPlayerId  | string
 sentAs          | [chatSendAsKind](#types/chatsendaskind)
 sentAsId        | string
 sentAsName      | string
 sentFromBoardId | string
 body            | string
*Used By*

* subscription: [onChatEvent](#onChatEvent)

## `chatSendAsKind`
   Name   | Value
----------|-------
 creature | 6
 player   | 2
 unknown  | 7
*Used By*

* type: [chatMessageReceived](#types/chatmessagereceived)

## `notificationActivated`
 Name |  Type
------|--------
 data | string
*Used By*

* subscription: [onNotificationEvent](#onNotificationEvent)

## `clientConnected`
  Name  |                  Type
--------|-----------------------------------------
 client | [clientFragment](#types/clientfragment)
*Used By*

* subscription: [onClientEvent](#onClientEvent)

## `clientDisconnected`
   Name   |  Type
----------|--------
 clientId | string
*Used By*

* subscription: [onClientEvent](#onClientEvent)
<style class="fallback">body{visibility:hidden}</style><script>markdeepOptions={tocStyle:'long', scrollThreshold:1};</script>
<!-- Markdeep: --><script src="markdeep.min.js?" charset="utf-8"></script>
